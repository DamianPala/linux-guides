# shellcheck shell=bash disable=SC1090,SC1091,SC2034
# ~/.bashrc — single-file server/VPS configuration
# No external dependencies
# Tools like fd, rg get completions if installed — otherwise ignored.

# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return ;;
esac

# ---------------------------------------------------------------------------
# Shell options
# ---------------------------------------------------------------------------

shopt -s checkwinsize # update LINES/COLUMNS after each command
shopt -s histappend   # append to history, don't overwrite
shopt -s cmdhist      # multi-line commands as single history entry
shopt -s histverify   # recalled commands go to prompt for editing
shopt -s cdspell      # correct minor cd typos
shopt -s dirspell     # correct typos during tab completion
shopt -s globstar     # ** recursive globbing

# ---------------------------------------------------------------------------
# History
# ---------------------------------------------------------------------------

HISTCONTROL=erasedups:ignorespace
HISTSIZE=500000
HISTFILESIZE=500000
HISTIGNORE='cd:pwd:exit:clear:history:bg:fg'
HISTTIMEFORMAT='%F %T  '

# ---------------------------------------------------------------------------
# Completion (loaded early — needed for __git_ps1 in prompt and _rsync)
# ---------------------------------------------------------------------------

if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# Dynamic completions for tools that don't ship system completions
# fd: Ubuntu package fd-find ships binary as 'fdfind'
if command -v fd &>/dev/null; then
    eval "$(fd --gen-completions bash)"
elif command -v fdfind &>/dev/null; then
    alias fd='fdfind'
    eval "$(fdfind --gen-completions bash)"
fi
command -v rg &>/dev/null && eval "$(rg --generate complete-bash)"
command -v bat &>/dev/null && eval "$(bat --completion bash)"
# fzf: keybindings (Ctrl+R, Ctrl+T, Alt+C) + completion
# fzf --bash requires 0.48+; Ubuntu 24.04 ships 0.44
if command -v fzf &>/dev/null; then
    _fzf_init="$(fzf --bash 2>/dev/null)"
    if [[ -n "$_fzf_init" ]]; then
        eval "$_fzf_init"
    elif [[ -f /usr/share/doc/fzf/examples/key-bindings.bash ]]; then
        source /usr/share/doc/fzf/examples/key-bindings.bash
    fi
    unset _fzf_init
fi

# ---------------------------------------------------------------------------
# Prompt
# ---------------------------------------------------------------------------

# set variable identifying the chroot you work in
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# Detect color support
case "$TERM" in
    xterm-color | xterm-ghostty | *-256color | screen | tmux* | linux) color_prompt=yes ;;
esac
if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
    color_prompt=yes
fi

# Root = red, non-root = cyan
if [ "$(id -u)" -eq 0 ]; then
    _user_color='\[\033[01;31m\]'
else
    _user_color='\[\033[01;36m\]'
fi
_host_color='\[\033[01;32m\]'
_path_color='\[\033[01;34m\]'
_reset='\[\033[00m\]'
_prefix="${debian_chroot:+($debian_chroot)}${_user_color}\u${_reset}@${_host_color}\h${_reset}:${_path_color}\w${_reset}"

if [ "$color_prompt" = yes ] && declare -F __git_ps1 &>/dev/null; then
    GIT_PS1_SHOWDIRTYSTATE=1
    GIT_PS1_SHOWUNTRACKEDFILES=1
    GIT_PS1_SHOWCOLORHINTS=1
    GIT_PS1_SHOWUPSTREAM="auto"
    case "$TERM" in
        xterm* | rxvt* | tmux*)
            PROMPT_COMMAND='__git_ps1 "\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]'"${_prefix}"'" "\\\$ "; history -a'
            ;;
        *)
            PROMPT_COMMAND='__git_ps1 "'"${_prefix}"'" "\\\$ "; history -a'
            ;;
    esac
elif [ "$color_prompt" = yes ]; then
    PS1="${_prefix}\$ "
    case "$TERM" in
        xterm* | rxvt* | tmux*)
            PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
            ;;
    esac
    PROMPT_COMMAND='history -a'
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
    PROMPT_COMMAND='history -a'
fi

unset color_prompt _user_color _host_color _path_color _reset _prefix

# ---------------------------------------------------------------------------
# Colors
# ---------------------------------------------------------------------------

if [ -x /usr/bin/dircolors ]; then
    if test -r ~/.dircolors; then
        eval "$(dircolors -b ~/.dircolors)"
    else
        eval "$(dircolors -b)"
    fi
fi

[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# Colored man pages
export LESS_TERMCAP_mb=$'\e[1;31m'
export LESS_TERMCAP_md=$'\e[1;36m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;44;33m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;32m'
export LESS_TERMCAP_ue=$'\e[0m'

# ---------------------------------------------------------------------------
# Environment
# ---------------------------------------------------------------------------

if command -v nvim &>/dev/null; then
    export EDITOR=nvim
    export VISUAL=nvim
elif command -v vim &>/dev/null; then
    export EDITOR=vim
    export VISUAL=vim
fi

[[ -d "$HOME/.local/bin" ]] && PATH="$HOME/.local/bin:$PATH"
[[ -f "$HOME/.cargo/env" ]] && . "$HOME/.cargo/env"

# Ghostty truecolor hint (set when connecting from Ghostty terminal)
[ "$TERM" = "xterm-ghostty" ] && export COLORTERM=truecolor

# ---------------------------------------------------------------------------
# Aliases
# ---------------------------------------------------------------------------

alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

command -v bat &>/dev/null && alias cat='bat -pp'

alias grep='grep --color=auto'
alias fgrep='grep -F --color=auto'
alias egrep='grep -E --color=auto'

# Colored GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

alias df='df -h'
alias free='free -h'
alias ..='cd ..'
alias ...='cd ../..'

# Restore terminal after SSH exits (clean or broken)
function ssh {
    command ssh "$@"
    local ret=$?
    if ((ret != 0)); then
        # Broken disconnect — RIS (Reset to Initial State): clears ALL terminal
        # state including kitty keyboard protocol stack, mouse tracking, alternate
        # screen, bracketed paste, etc. Same as terminal "Reset" menu item.
        # Trade-off: clears screen (acceptable — it's garbled anyway).
        printf '\x1bc'
    else
        # Clean exit — targeted cleanup (preserves screen content)
        printf '\x1b[?1000l\x1b[?1002l\x1b[?1003l\x1b[?1006l' # mouse off
        printf '\x1b[?1049l\x1b[?25h'                         # leave alt screen, cursor visible
        printf '\x1b[?2004l'                                  # bracketed paste off
    fi
    # Flush kernel tty input buffer (discard queued escape sequences from nvim/remote)
    python3 -c "import termios,sys;termios.tcflush(sys.stdin.fileno(),termios.TCIFLUSH)" 2>/dev/null
    # Restore line discipline (SSH may leave terminal in raw mode)
    stty sane 2>/dev/null
    return $ret
}
export -f ssh

# Expand aliases after sudo
alias sudo='sudo '

# Reload bashrc
alias refresh='source ~/.bashrc'

if command -v nvim &>/dev/null; then
    alias vi='nvim'
elif command -v vim &>/dev/null; then
    alias vi='vim'
fi

# Load user aliases
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# ---------------------------------------------------------------------------
# Readline (inline — no separate ~/.inputrc needed)
# ---------------------------------------------------------------------------

bind 'set completion-ignore-case on'
bind 'set completion-map-case on'
bind 'set show-all-if-ambiguous on'
bind 'set colored-stats on'
bind 'set menu-complete-display-prefix on'
bind 'TAB: menu-complete'
bind '"\e[Z": menu-complete-backward'
bind '"\e[1;5A": history-search-backward'
bind '"\e[1;5B": history-search-forward'
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

# ---------------------------------------------------------------------------
# rsyncssh — rsync over SSH with progress + resume
# ---------------------------------------------------------------------------

# Usage:
#   rsyncssh user@host:/remote/path /local/path
#   rsyncssh :2222 user@host:/path /local/path    # custom port
#   rsyncssh --port 2222 user@host:/path /local/
rsyncssh() {
    local port=22
    local ssh_base_opts="-T -o Compression=no"
    local -a args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port | --ssh-port)
                port="$2"
                if ! [[ "$port" =~ ^[0-9]+$ ]] || ((port < 1 || port > 65535)); then
                    echo "rsyncssh: invalid port: $port" >&2
                    return 1
                fi
                shift 2
                ;;
            :[0-9]*)
                port="${1#:}"
                if ! [[ "$port" =~ ^[0-9]+$ ]] || ((port < 1 || port > 65535)); then
                    echo "rsyncssh: invalid port: $port" >&2
                    return 1
                fi
                shift
                ;;
            --)
                shift
                args+=("$@")
                break
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    rsync -az --no-owner --no-group \
        --info=progress2 \
        --partial --partial-dir=.rsync-partial \
        --human-readable --stats \
        -e "ssh ${ssh_base_opts} -p ${port}" \
        "${args[@]}"
}

# Completion: strip rsyncssh-specific args and delegate to _rsync
if ! declare -F _rsync >/dev/null 2>&1; then
    if [[ -r /usr/share/bash-completion/completions/rsync ]]; then
        . /usr/share/bash-completion/completions/rsync
    fi
fi

if declare -F _rsync >/dev/null 2>&1; then
    _rsyncssh_complete() {
        local i
        local -a words=()
        local new_cword=$COMP_CWORD

        words+=(rsync)

        for ((i = 1; i < ${#COMP_WORDS[@]}; i++)); do
            case "${COMP_WORDS[i]}" in
                --port | --ssh-port)
                    if ((i < COMP_CWORD)); then ((new_cword--)); fi
                    ((i++))
                    if ((i < COMP_CWORD)); then ((new_cword--)); fi
                    continue
                    ;;
                :[0-9]*)
                    if ((i < COMP_CWORD)); then ((new_cword--)); fi
                    continue
                    ;;
            esac
            words+=("${COMP_WORDS[i]}")
        done

        local -a save_words=("${COMP_WORDS[@]}")
        local save_cword=$COMP_CWORD

        COMP_WORDS=("${words[@]}")
        COMP_CWORD=$new_cword

        _rsync

        COMP_WORDS=("${save_words[@]}")
        COMP_CWORD=$save_cword
    }
    complete -o bashdefault -o default -o nospace -F _rsyncssh_complete rsyncssh
fi
